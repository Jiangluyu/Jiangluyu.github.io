<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用排序算法详解]]></title>
    <url>%2F2020%2F03%2F02%2F%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[排序算法Playground在线运行地址：https://leetcode-cn.com/playground/rKzLfEEY/ 排序算法 平均时间复杂度 最好情况 最坏情况 空间复杂度 排序方式 稳定性 冒泡排序 O(n²) O(n) O(n²) O(1) In-place 稳定 选择排序 O(n²) O(n²) O(n²) O(1) In-place 不稳定 插入排序 O(n²) O(n) O(n²) O(1) In-place 稳定 希尔排序 O(nlogn) O(nlogn) O(nlogn) O(1) In-place 不稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) Out-place 稳定 快速排序 O(nlogn) O(nlogn) O(n²) O(logn) In-place 不稳定 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) In-place 不稳定 计数排序 O(n+k) O(n+k) O(n+k) O(k) Out-place 稳定 桶排序 O(n+k) O(n+k) O(n²) O(n+k) Out-place 稳定 基数排序 O(n×k) O(n×k) O(n×k) O(n+k) Out-place 稳定 注： 稳定性：相同数字是否保持原顺序 排序方式：是否需要占据额外空间，需要为Out-place，不需要为In-place 以下代码实现均为升序（小→大） 冒泡排序思想：遍历数组n次（n为数的个数），比较两个数的大小，较大的数下沉，较小的数上浮。 12345678910void bubble_sort(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(); for (int i = 0; i &lt; size - 1; i++) &#123; // 表示第i轮 for (int j = size - 1; j &gt; i; j--) &#123; // 从最后一个数开始依次向前比较，由于每次将最小的数浮到水面（即i）以上，因此每过一轮，需要比较的次数就变少一次 if (arr[j] &lt; arr[j-1]) &#123; swap(arr[j], arr[j-1]); &#125; &#125; &#125;&#125; 优化：由于数据顺序排好以后，冒泡算法仍然会进行下一轮的比较，尽管后面的遍历都是多余的。因此，设置标志位，若某一轮没有发生交换，则结束排序。 12345678910111213141516void bubble_sort_op(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(); bool flag = false; for (int i = 0; i &lt; size - 1; i++) &#123; flag = false; for (int j = size - 1; j &gt; i; j--) &#123; if (arr[j] &lt; arr[j-1]) &#123; swap(arr[j], arr[j-1]); flag = true; &#125; &#125; if (!flag) &#123; break; &#125; &#125;&#125; 选择排序思想：每次选择数组中剩余数中最小的，将其放到前面（与对应位置的数交换） 123456789101112void selection_sort(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(); for (int i = 0; i &lt; size - 1; i++) &#123; int minIdx = i; for (int j = size - 1; j &gt; i; j--) &#123; if (arr[j] &lt; arr[minIdx]) &#123; minIdx = j; &#125; &#125; swap(arr[i], arr[minIdx]); &#125;&#125; 插入排序思想：遍历数组，第k个数分别与前k-1个数比较，找到自己的位置并插入（实现上还是用的交换）。 123456789101112void insertion_sort(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(); for (int i = 1; i &lt; size; i++) &#123; // 表示第i轮 for (int j = i; j &gt; 0; j--) &#123; // 从第二个数开始，与前面的数依次比较，直到找到位置 if (arr[j] &lt; arr[j-1]) &#123; swap(arr[j], arr[j-1]); &#125; else &#123; break; &#125; &#125; &#125;&#125; 希尔排序思想：又叫最小增量排序，将要排序的数组根据某个增量分为若干子序列，并对子序列进行插入排序，然后将增量逐渐缩小，重复上述过程，直至增量为1，此时数组基本有序，最后再进行插入排序。 帮助理解： 假设有一组数据： 59 20 17 13 28 14 23 83 第一轮：增量为4（子序列为[0, 4], [1, 5], [2, 6], [3, 7]) 首先i=4，即选中arr[4]即28，将其与arr[4-4]即59作为一个子序列进行插入排序，结果为： 28 20 17 13 59 14 23 83 接着i=5，即选中arr[5]即14，将其与arr[5-4]即20作为一个子序列进行插入排序，结果为： 28 14 17 13 59 20 23 83 接着i=6，即选中arr[6]即23，将其与arr[6-4]即17作为一个子序列进行插入排序，由于17&lt;23，序列不变； 接着i=7，即选中arr[7]即83，将其与arr[5-4]即13作为一个子序列进行插入排序，由于13&lt;83，序列不变； 最终结果为： 28 14 17 13 59 20 23 83 第二轮：增量为2（子序列为[0, 2, 4, 6], [1, 3, 5, 7]) 结果为： 17 13 23 14 28 20 59 83 第三轮：增量为1 即将整个数组作为序列进行插入排序，结果为： 13 14 17 20 23 28 59 83 1234567891011121314void shell_sort(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(); for (int incr = size / 2; incr &gt; 0; incr /= 2) &#123; // 表示增量increment for (int i = incr; i &lt; size; i++) &#123; // 根据增量划分子序列并进行插入排序 for(int j = i; j &gt;= incr; j -= incr) &#123; if (arr[j-incr] &gt; arr[j]) &#123; swap(arr[j], arr[j-incr]); &#125; else &#123; break; &#125; &#125; &#125; &#125;&#125; 归并排序思想：分治法，将数组分成两组A，B，如果A，B组内有序，那么归并这两个子序列就得到了有序序列，为了使A，B有序，以此类推，将A，B分别再分成两组，如此分下去，直到每个组内只有一个数字时，该子序列就达到了有序，最后我们将相邻子序列两两归并即可。 动态版： 静态版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void merge_sort(vector&lt;int&gt;&amp; arr, int begin, int end) &#123; if (begin &lt; end) &#123; int mid = (begin + end) / 2; merge_sort(arr, begin, mid); // 将左半部分排好序 merge_sort(arr, mid + 1, end); // 将右半部分排好序 merge(arr, begin, mid, end); // 归并左右部分 &#125;&#125;void merge(vector&lt;int&gt;&amp; arr, int begin, int mid, int end) &#123; int i = 0; int j = 0; int k = 0; int size = end - begin + 1; vector&lt;int&gt; temp(size, 0); int pLeft = begin; int pRight = mid + 1; bool endLeft = false; bool endRight = false; for (i = 0; i &lt; size; i++) &#123; if (!endLeft &amp;&amp; !endRight) &#123; // 若左右序列均未到达终点 if (arr[pLeft] &lt; arr[pRight]) &#123; // 取左右指针所指向元素中较小的那一个 temp[i] = arr[pLeft++]; &#125; else &#123; temp[i] = arr[pRight++]; &#125; if (pLeft &gt; mid) &#123; // 判定左右序列是否已到达终点，若是则标记 endLeft = true; &#125; if (pRight &gt; end) &#123; endRight = true; &#125; &#125; else &#123; // 若左右至少有一个已经到达终点，则将未到达终点的序列剩余部分加在temp后面 if (!endLeft) &#123; temp[i] = arr[pLeft++]; &#125; else &#123; temp[i] = arr[pRight++]; &#125; &#125; &#125; for (j = 0, k = begin; j &lt; size; j++, k++) &#123; // 将temp中的数按序存回arr arr[k] = temp[j]; &#125;&#125; 快速排序思想：分治法，先从序列中选出一个数作为pivot，将比这个数小的数放在其左边，大的数放在其右边。然后，对左右两个子序列重复上一步，直至各子区间内只有一个数。 动态版： 帮助理解： 例如，我们有这样一组序列：72 6 57 88 60 85 42 83 73 48，初始化pivot=60（这里的pivot为arr[begin], arr[mid], arr[end]的中间值），将其交换至末尾。 对该序列进行划分： 72 6 57 88 85 42 83 73 48 60 l r pivot 48 6 57 88 85 42 83 73 72 60 l r pivot 48 6 57 42 85 88 83 73 72 60 r l pivot 48 6 57 42 60 88 83 73 72 85 r l 对[48, 6, 57 ,42]，[88, 83, 73, 72, 85]进行划分：正好各自的pivot都在末尾。 48 6 57 42 \ 88 83 73 72 85 l1 r1 pivot1 \ l2 r2 pivot2 48 6 57 42 \ 75 83 73 88 85 l1 r1 pivot1 \ r2 l2 pivot2 6 48 57 42 \ 75 83 73 85 88 r1 l1 pivot1 \ r2 l2 6 42 57 48 \ r1 l1 \ [6], [88]不用划分，对[57, 48]，[75, 83, 73]划分：前者pivot=48，后者pivot=75，交换至末尾 \ \ 57 48 \ 73 83 75 \ \ \ \ l1, r1 pivot1 \ l1 r1 pivot2 \ \ \ \ 48 57 \ 73 83 75 \ \ \ \ l1, r1 \ r1 l1 pivot2 \ \ \ \ \ 73 75 83 \ \ \ \ \ r1 l1 \ \ 至此，排序完成。 最终序列为： 6 42 48 57 60 73 75 83 85 88 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int find_pivot(vector&lt;int&gt;&amp; arr, int begin, int end) &#123; // 返回arr[begin], arr[mid], arr[end]的中间值 int mid = (begin + end) &gt;&gt; 1; if (arr[begin] &lt; arr[end]) &#123; if (arr[end] &lt; arr[mid]) &#123; return end; &#125; else if (arr[begin] &gt; arr[mid]) &#123; return begin; &#125; else &#123; return mid; &#125; &#125; else &#123; if (arr[end] &gt; arr[mid]) &#123; return end; &#125; else if (arr[begin] &lt; arr[mid]) &#123; return begin; &#125; else &#123; return mid; &#125; &#125;&#125;int partition(vector&lt;int&gt;&amp; arr, int begin, int end, int pivot) &#123; while (true) &#123; while (arr[begin] &lt; pivot) &#123; // 从左开始找到第一个比pivot大的值 begin++; &#125; end--; // 调整（若不调整，会将放在end处的pivot交换到别的位置） while (arr[end] &gt; pivot) &#123; // 从右开始找到第一个比pivot小的值 end--; &#125; if (begin &gt;= end) &#123; return begin; // 返回比pivot大的第一个值，即右序列的第一个位置 &#125; else &#123; swap(arr[begin], arr[end]); begin++; // 调整 &#125; &#125;&#125;void quick_sort(vector&lt;int&gt;&amp; arr, int begin, int end) &#123; if (begin &gt;= end) &#123; return; &#125; else &#123; int pivotIdx = find_pivot(arr, begin, end); swap(arr[pivotIdx], arr[end]); // 将pivot放在序列末尾 int bgRight = partition(arr, begin, end, arr[end]); // partition的返回值为右序列（比pivot大）的第一个位置，注意pivot已经被交换到末尾，故传入的pivot为arr[end] swap(arr[bgRight], arr[end]); // 将pivot值放回中间，使左序列比pivot大，右序列比pivot小 quick_sort(arr, begin, bgRight-1); // 对左序列重新排序 quick_sort(arr, bgRight+1, end); // 对右序列重新排序 &#125;&#125; 堆排序计数排序思想：空间换取时间，计算每个数的次数，最后遍历并存入原数组. 1234567891011121314151617181920void counting_sort(vector&lt;int&gt;&amp; arr) &#123; int maxNum = INT_MIN; int size = arr.size(); for (int i = 0; i &lt; size; i++) &#123; maxNum = max(maxNum, arr[i]); &#125; int range = maxNum + 1; vector&lt;int&gt; temp(range, 0); for (int i = 0; i &lt; size; i++) &#123; // 计数 ++temp[arr[i]]; &#125; for (int i = 0, j = -1; i &lt; range; i++) &#123; // 遍历每个数槽 for (int k = 0; k &lt; temp[i]; k++) &#123; // 取出该数，直到达到之前的计数 arr[++j] = i; &#125; &#125;&#125; 优化：创建max-min+1个空间，减少空间浪费 12345678910111213141516171819202122void counting_sort_op(vector&lt;int&gt;&amp; arr) &#123; int maxNum = INT_MIN; int minNum = INT_MAX; int size = arr.size(); for (int i = 0; i &lt; size; i++) &#123; maxNum = max(maxNum, arr[i]); minNum = min(minNum, arr[i]); &#125; int range = maxNum - minNum + 1; vector&lt;int&gt; temp(range, 0); for (int i = 0; i &lt; size; i++) &#123; temp[arr[i]-minNum]++; &#125; for (int i = 0, j = -1; i &lt; range; i++) &#123; for (int k = 0; k &lt; temp[i]; k++) &#123; arr[++j] = i + minNum; &#125; &#125;&#125; 桶排序思想：分治法，桶排序是计数排序的扩展版本，计数排序可以看成每个桶只存储相同元素，桶排序每个桶存储一定范围的元素，通过映射函数，将待排序数组中的元素映射到各个对应的桶中，对每个桶中的元素进行排序，最后将非空桶中的元素逐个放入原序列中。 静态版： 123456789101112131415161718192021222324252627void bucket_sort(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(); vector&lt;int&gt; temp[size]; int maxNum = INT_MIN; int minNum = INT_MAX; for (int i = 0; i &lt; size; i++) &#123; // 确定最大最小值 maxNum = max(maxNum, arr[i]); minNum = min(minNum, arr[i]); &#125; for (int i = 0; i &lt; size; i++) &#123; int bucketNum = (int)(arr[i] - minNum) / (maxNum - minNum + 1) * size; // 加1是为了确保bucketNum &lt; size temp[bucketNum].push_back(arr[i]); &#125; for (int i = 0; i &lt; size; i++) &#123; // 将每个桶内排序 sort(temp[i].begin(), temp[i].end()); &#125; int idx = 0; for (int i = 0; i &lt; size; i++) &#123; // 按序将桶内排好序的数字拷回arr for (int j = 0; j &lt; temp[i].size(); j++) &#123; arr[idx++] = temp[i][j]; &#125; &#125;&#125; 基数排序思想：首先了解分配排序(binsort)，即创建数组A[MaxValue]；然后将每个数放到相应的位置上（例如17放在下标17的数组位置）；最后遍历数组，即为排序后的结果。 静态版： 问题在于，当序列中的元素分布不集中时，会造成大量的空间开销。 基数排序即在此基础上，通过基数的限制减少空间开销。 静态版： 1234567891011121314151617void count_sort(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(); vector&lt;int&gt; temp(size, 0);&#125;void radix_sort(vector&lt;int&gt;&amp; arr) &#123; int maxNum = INT_MIN; int size = arr.size(); int exp = 0; //记录最大数的位数 for (int i = 0; i &lt; size; i++) &#123; maxNum = max(maxNum, arr[i]); &#125; for (exp = 1; maxNum / exp &gt; 0; exp *= 10) &#123; count_sort(arr, exp); &#125;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今日母亲为我理发]]></title>
    <url>%2F2020%2F02%2F29%2F%E4%BB%8A%E6%97%A5%E6%AF%8D%E4%BA%B2%E4%B8%BA%E6%88%91%E7%90%86%E5%8F%91%2F</url>
    <content type="text"><![CDATA[因疫情缘故， 头发极长， 于是今日母亲用网购来的推子与剪子， 为我们爷俩剪了头， 十分满意。 父亲发型阴差阳错， 甚是新潮。]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>活在此时</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++set详解]]></title>
    <url>%2F2020%2F02%2F27%2FC%2B%2Bset%2F</url>
    <content type="text"><![CDATA[关于C++ STL set的用法以及知识延伸。 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main(void)&#123; set&lt;int&gt; nums; for (int i = 0; i &lt; 10; i++) &#123; nums.insert(i); &#125; // 等效 set&lt;int&gt;::iterator it = nums.begin(); auto it = nums.begin(); for (it; it != nums.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125;&#125; 常见用法1234567891011121314151617181920212223242526272829303132333435363738begin() // 返回指向set容器第一个元素的迭代器end() // 返回指向set容器最后一个元素的迭代器，不存值 rbegin() // 等效end() rend() // 等效begin() clear() // 清空set容器 empty() // 判断set容器是否为空 max_size() // 返回set容器可能包含元素的最大个数 size() // 返回当前set容器中的元素个数 insert(x) // 向set容器中插入值x，返回值为pair&lt;it, bool&gt;，bool表示是否成功，it指向x在set中的位置 insert(it_start, it_end) // 向set中插入两迭代器中间的值 erase(x) // 从set容器中删除值x，若x为迭代器，则删除迭代器指向的值 erase(it_start, it_end) // 删除set中两迭代器中间的值，包括*it_start，不包括*it_end count(x) // 计算set中x出现的次数，在set中只可能为1或0 find(x) // 若找到x，则返回指向x的迭代器，否则返回end() lower_bound(x) // 返回指向第一个大于等于x的值的迭代器 upper_bound(x) // 返回指向第一个大于x的值的迭代器// 返回pair&lt;it, it&gt;，即在两迭代器内，所有等于x的值的范围，即第一个x的位置与最后一个x的位置，set中若不存在x则两值相等equal_range(it_begin, it_end, x) set1.insert(set2.begin(), set3.end()) // set1 = set2 ∪ set3 并去重set1.swap(set2) // 两个set内容交换 知识延伸map和set插入删除效率比其他序列容器高的原因： 底层实现为红黑树，对于关联容器来说，不需要做内存拷贝和内存移动。set容器内所有元素都是以节点的方式来存储，其节点结构和链表差不多，指向父节点和子节点。 map在每次insert、erase操作之后，以前的迭代器是否会过期？ 不会，注意vector在进行相应操作后迭代器可能会过期。 插入、搜索元素时，效率如何？ set中使用的是二分查找，时间复杂度为logn，换言之，数据增大一倍时，搜索次数会多1次。 如何求并集、交集、差集、对称差集（A∪B-A∩B）？ 1234567891011121314&gt; #include &lt;algorithm&gt;&gt; &gt; // 交集&gt; set_intersection(it1_start, it1_end, it2_start, it2_end, inserter(res, res.begin()))&gt; &gt; // 差集&gt; set_difference(it1_start, it1_end, it2_start, it2_end, inserter(res, res.begin()))&gt; &gt; // 并集&gt; set_union(it1_start, it1_end, it2_start, it2_end, inserter(res, res.begin()))&gt; &gt; // 对称差集&gt; set_symmetry_difference(it1_start, it1_end, it2_start, it2_end, inserter(res, res.begin()))&gt;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[E021-合并两个有序链表]]></title>
    <url>%2F2020%2F02%2F21%2FE021-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 方法一：递归思路即每次挑选一个“头”节点，在剩下的节点中再递归挑选“头”节点，直至有一个链表被挑光，即为空。 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == NULL) &#123; return l2; &#125; else if (l2 == NULL) &#123; return l1; &#125; if (l1-&gt;val &lt; l2-&gt;val) &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; 复杂度分析 时间复杂度：O(m + n)，m，n分别为l1,l2的元素个数。递归函数每次去掉一个元素，直到两个链表都为空，因此需要调用R=O(m + n)次。而在递归函数中我们只进行了next指针的赋值操作，复杂度为O(1)，故递归的总时间复杂度为O(m + n)。 空间复杂度：O(m + n)，递归调用了该函数m + n次，使用了m + n个栈帧，故空间复杂度为O(m + n)。 方法二：迭代用一个prev指针维护当前接在结果中的最后一个节点，每次迭代要做的就是决定l1与l2中哪一个的剩余头节点成为prev-&gt;next。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == NULL) &#123; return l2; &#125; else if (l2 == NULL) &#123; return l1; &#125; ListNode* resHead = NULL; if (l1-&gt;val &lt; l2-&gt;val) &#123; resHead = l1; l1 = l1-&gt;next; &#125; else&#123; resHead = l2; l2 = l2-&gt;next; &#125; ListNode* prev = resHead; while (l1 != NULL &amp;&amp; l2 != NULL) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; prev-&gt;next = l1; prev = prev-&gt;next; l1 = l1-&gt;next; &#125; else &#123; prev-&gt;next = l2; prev = prev-&gt;next; l2 = l2-&gt;next; &#125; &#125; if (l1 == NULL) &#123; prev-&gt;next = l2; &#125; else if (l2 == NULL) &#123; prev-&gt;next = l1; &#125; return resHead; &#125;&#125;; 复杂度分析 时间复杂度：O(m + n)，m，n分别为l1,l2的元素个数，相当于遍历了两次较短链表的长度。 空间复杂度：O(1)，每次迭代只使用了同一个prev指针，因此为常数级复杂度。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电脑维修实用问题汇总]]></title>
    <url>%2F2020%2F02%2F21%2F%E7%94%B5%E8%84%91%E7%BB%B4%E4%BF%AE%E5%AE%9E%E7%94%A8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[一些常用问题汇总。 实用问题汇总：硬件 进水 进水的问题一定要马上和机主联系，不可耽误，如果没法第一时间接单，就让机主马上送去维修，或者将单子转给别的技术员，总之处理要快 询问机主是什么时候进的水？进的是什么水？进了多少水？进水之后做了什么？（如果遇上神仙机主，机子进水了还不拆开开始晒干，等过了一两天才找你，甚至进完水没多久觉得可以了还开机的，这种单子最好就别接了） 如果还来得及，提醒机主一定不能开机，再接到机子后，首先把电源拆掉（个人建议这里别放静电，放了有可能出事），如果发现进水量过大，已经渗入主板内，先用纸把周围的水吸附掉，把硬盘拆下来（电脑出问题优先保住硬盘），继续吸附水，然后接着拆，以此循环，把能吸附的水吸附掉后，视情况建议机主送去维修店烘干。如果倒入的是饮料。。。尽力而为吧，某些地方可以用酒精纸（不过多半救不了），同样能处理完后让机主送去维修 如果以上更糟糕的情况没有发生，则将拆开后的本子和配件放在通风处（不能让阳光直射），等待晾干，原则上是至少要晾3天 清灰 顺序：拆机→清理风扇→清理其他→装机 注意：分清螺丝、视电脑拆机难度，决定拆机层次，结构比较复杂的尽量降低拆机的层次（但依然要把电池拆下来）、用皮老虎，角度尽量贴近风扇平面，对着扇叶吹，吹的方向应该是风扇靠近笔记本边缘的方向，以免吹出来的灰尘落到元件上，吹的过程中可用小刷子擦拭扇叶，帮助清理。吹完后，用小刷子轻轻扫过平面，将残留的灰尘扫出去。最后用皮老虎再吹，如果基本没有灰尘吹出，则差不多清理完毕 花屏 有能力的可以拆屏幕框重新插拔排线，否则直接建议机主售后 扩容 硬盘：注意主板接口与硬盘接口是否匹配（要熟知常见的接口！） 内存：注意内存的接口类型（DDR3、DDR3L、DDR4）以及频率（向下兼容，按最低的算） 软件 系统 系统镜像去MSDN下载原版 制作PE盘（去微PE官网下载或使用飞扬的镜像，其实是一个东西） 激活使用KMS（建议使用胡萝卜周博客中下载的版本） 常用软件（常备安装文件！安装失败时注意错误代码！） 驱动人生、驱动精灵，重装电脑时使用装机版，其他情况下只有当有问题时才尝试升级、重装驱动，不要随意升级其他正常工作的驱动！ Microsoft Office Adobe AutoCAD 注：在安装CAD等软件过程中报错，比起直接搜索“安装到哪里不动“”安装XXX出错”，先查看这类软件的安装日志，看看安装日志是在哪一步失败，再推断和搜索安装原因是最高效、最准确的（如果你找得到安装日志的话，大部分的软件应该都有，因为写他们的程序员自己也要看） 常见问题Q1：网页打不开 检查网络连接是否正常 检查是否启动代理（SSR之类），小飞机启动后选择关闭有时也会导致无法打开网页 检查防火墙设置，将浏览器或其他连不了网络的软件添加至例外中 清除缓存与Cookie信息[IE中：工具→Internet选项→常规→浏览历史记录→删除]，CC登不上时常用 使用360断网急救箱 Q2：蓝牙连不上 检查是否打开蓝牙 检查是否开了飞行模式而自动关闭蓝牙 查看蓝牙驱动[设备管理器→蓝牙]，哪里不对，更新哪里 Win+R打开运行，输入services.msc，查看其中与蓝牙有关的服务项（如Bluetooth Support Service），如果有禁用的，则改为自动启动 麻烦的情况：能做的都做了，重启后有时可以有时不行（大概率在冬天），这是一个玄学问题，售后或者一般等天气回暖就好了 Q3：广告弹窗 打开任务管理器，定位弹窗广告的进程，右键选择“打开文件所在的位置”，打开后删掉或者卸载相关文件，并关掉对应的进程便可 如果不能确定哪个进程是弹窗广告的话，要进行试错，选择从没见过、从命名不能理解进程用途、非系统文件命名方式的进程，先打开文件所在位置，然后关掉进程，如果弹窗消失，说明找到了 部分弹窗运行文件删除的时候可能没有权限（真的非常流氓），可以进入Window10的安全模式（Win+R，输入msconfig，勾选安全引导，点击确定，重启电脑便好），再去相应的文件位置删除（安全模式能够自动获取权限） 如果机主反馈弹窗又重新出现，你发现原来的弹窗文件又生成了，而机主又不愿意卸载使其生成的软件（以金山毒霸为首），那么可以使用“偷天换日”的做法：复制弹窗对应的exe文件的文件名，将原来的文件删掉后，在原来的位置新建立一个txt文件，将文件名改为复制的文件名（记得修改后缀），然后右键改文件，点击“属性”，在“安全”中点击编辑，在权限窗口中勾选“拒绝”一栏，这样当软件想要读取的时候就会“哑火” 具体可参照这个链接：https://jingyan.baidu.com/article/3a2f7c2e51d76d67afd611be.html 常见的弹窗系软件：360系，爱奇艺，腾讯视频，2345系（好压、看图王等），搜狐系 懒人法：火绒的弹窗管理 Q4：电脑启动慢、卡顿 若电脑服役时间较久（有的甚至是没有SSD的年代的电脑），最好选择硬件升级 启动慢修改开机启动项：Win+R，输入msconfig，在常规一栏中选择有选择的启动，并勾选加载启动项，到启动一栏中对启动项进行调整 懒人法：火绒的启动项管理 Q5：系统重装 注意事项：询问机主是否需要备份，以及重装后需要重新安装的软件 Q6：电脑没声音 使用声音疑难解答[声音图标（右键）→声音问题疑难解答]（这个检测出的问题常常可以作为百度的关键词，比直接搜索问题要精准一点） 设置扬声器为默认设备[声音图标（右键）→打开音量合成器→系统声音→播放] 扬声器还原默认值[扬声器（右键）→高级→还原默认值] 检查驱动[开始图标右键→设备管理器（快捷键Win+X, M）→声音、视频和游戏控制器设备管理器→Realtek High Definition Audio（或Realtek Audio）]，使用驱动精灵进行重装或更新 存在特殊情况：笔记本插上耳机有声音，外放没声音。在以上方法排除后，依然出现这种情况，那么打开设备管理器，点击系统设备，找到英特尔智音技术控制器，右键点击选择更新驱动就好了，再选择“自动搜索”或者“浏览计算机”，如果是后者的话，应该选择的驱动是High Definition Audio（这个我找不到之前的解决链接了，按照记忆写了一下，找“智音技术”准没错） Q7：连不上网 无线网：（以下方法按顺序进行，若都无效可能是硬件问题，建议售后） 查看是否进入了飞行模式[右下角网络图标→飞行模式] 查看设备管理器中的驱动状态[左下角开始图标右键→设备管理器（快捷键Win+X, M）→网络适配器]，有线网一般是带有PCIe的字样，无线网一般是带有Wireless，如果对应驱动出现红叉或者警告标志，一般是驱动出了问题，更新或者重新安装就行了，没有的话，直接尝试重新安装 使用系统自带的疑难解答[右下角网络图标→设置→网络疑难解答] 尝试360断网急救箱 Win+R打开运行，输入cmd，在命令提示符中输入命令回车并重启： 1netsh winsock reset 较为麻烦的情况：网络列表上没有可连接的网络，设备管理器中找不到对应驱动，甚至在”网络和Internet”上找不到WLAN等表项，驱动精灵安装驱动时没有安装网卡驱动的选项，而且机主告诉你，他无线能用但有线不能或者反之或者皆不能，说明很有可能网卡硬件出了问题，拆机后对网卡重新插拔（注意记住连接网卡的两个小细线，连接的顺序和位置不能错）。要注意这个可插拔的网卡只管无线网！因此如果你再重新插拔后无线网依然没法用，或者以上情况中的主体是有线网，那么恭喜你，这电脑很有可能就修不好了（参照刘双嘉同学亲身经历）。这个麻烦情况大都出现在冬天，初步推断是硬件老化加上热胀冷缩引起的，建议送报修或者售后。 有线网：（以下方法按顺序进行，若都无效可能是硬件问题，建议售后） 检查网线是否插好，若仍提示网络电缆未插入可以尝试更换网线 使用系统自带的疑难解答[右下角网络图标→设置→网络疑难解答] 尝试360断网急救箱 Win+R打开运行，输入cmd，在命令提示符中输入命令回车并重启： 1netsh winsock reset 使用驱动精灵/驱动人生重新安装网卡驱动 写在后面除了动手以外，想做“好”的一定要对笔记本参数保持敏感，经常学习。 下面是一些推荐的信息源： 公众号：笔吧评测室 b站：翼王，Linus等 常用资源[软件安装] 微信公众号：软件安装管家 胡萝卜周博客（右上角放大镜检索）：http://www.carrotchou.blog MSDN：https://msdn.itellyou.cn/]]></content>
      <categories>
        <category>电脑维修</category>
      </categories>
      <tags>
        <tag>问题汇总</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[形近词辨析]]></title>
    <url>%2F2020%2F02%2F16%2F%E5%BD%A2%E8%BF%91%E8%AF%8D%E8%BE%A8%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一些常用形近词整理。 precipitate v.使(坏事等)突然发生；使沉淀；使水蒸气凝结； a.仓促的，鲁莽的，突如其来的； n.沉淀物 percipient a.敏锐的，有洞察力的，理解透彻的 perceive v.觉察，发觉，发现，感知，理解 mobilization n.动员；调动 mobility n.可动性；能动性；灵活性 defer v.推迟；服从 deter v.阻止 conclusive a.确定性的，决定性的，无争论余地的 exclusive a.独有的，独占的（= only）；排外的；高级的 exclusively adv.唯一的 cranial a.颅的 cardinal a.首要的，基本的]]></content>
      <categories>
        <category>TOEFL</category>
        <category>GRE</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[独立口语思路练习]]></title>
    <url>%2F2020%2F02%2F15%2F%E7%8B%AC%E7%AB%8B%E5%8F%A3%E8%AF%AD%E6%80%9D%E8%B7%AF%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[新托福口语思路练习。 Q1: Smart phone &amp; navigational devices or ask the locals for direction?Main idea: the former Reason 1: professional –&gt; accurate, efficient Example 1: locals maybe do not know or give obsolete information –&gt; slower, while navigational devices are always up-to-date Reason 2: no need to care about language problem Example 2: cannot speak Japanese, Last year travel to Japan, Google Map –&gt; not miss any event planned]]></content>
      <categories>
        <category>TOEFL</category>
      </categories>
      <tags>
        <tag>口语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[托福答题模板（自用）]]></title>
    <url>%2F2020%2F02%2F15%2F%E6%89%98%E7%A6%8F%E7%AD%94%E9%A2%98%E6%A8%A1%E6%9D%BF%EF%BC%88%E8%87%AA%E7%94%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[新托福口语答题模板总结。 TASK 1graph TD; A(Main idea)-->B(Reason 1)-->C(Reason 2) Template: When …, I’d …/Well honestly, I (dis)agree with the idea. The most obvious reason is that + sub idea 1. In my case/Take my own experience for example, … Another reason is that + sub idea 2. To be more specific/Specifically speaking,… (Those are the reasons why I am for/against the idea.) TASK 2Template: UNIV： The university is going to/announces that…because/in order to… S/T： A student/teacher suggests university should…because/in order to… The man/woman (dis)agrees with the idea. He/She says that…]]></content>
      <categories>
        <category>TOEFL</category>
      </categories>
      <tags>
        <tag>口语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[托福口语语料积累（更新中）]]></title>
    <url>%2F2020%2F02%2F15%2F%E6%89%98%E7%A6%8F%E5%8F%A3%E8%AF%AD%E8%AF%AD%E6%96%99%E7%A7%AF%E7%B4%AF%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[新托福口语语料总结。 句型 The most obvious reason is that…… In my case, …… Another reason is that…… 词组与help有关 turn to sb. for help = seek help from sb. be always around = be available with the help of sb. help sb., help sb. with sth., help sb. to do sth. offer sb. help, offer help to sb. provide sb. with help, provide help for sb. give sb. a hand]]></content>
      <categories>
        <category>TOEFL</category>
      </categories>
      <tags>
        <tag>口语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于hexo遇到的问题汇总]]></title>
    <url>%2F2020%2F02%2F15%2F%E5%85%B3%E4%BA%8Ehexo%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[一些迁移、安装hexo时遇到的问题及解决方法。 Q1: gyp: No Xcode or CLT version detected!近日在将hexo从win迁移到mac时，卡在了npm安装上： 运行如下命令时： 1npm install 出现如下错误： 123456789101112131415161718192021222324252627282930313233343536&gt; node installnode-pre-gyp WARN Tried to download(404): https://fsevents-binaries.s3-us-west-2.amazonaws.com/v1.2.4/fse-v1.2.4-node-v67-darwin-x64.tar.gznode-pre-gyp WARN Pre-built binaries not found for fsevents@1.2.4 and node@11.14.0 (node-v67 ABI, unknown) (falling back to source compile with node-gyp)No receipt for 'com.apple.pkg.CLTools_Executables' found at '/'.No receipt for 'com.apple.pkg.DeveloperToolsCLILeo' found at '/'.No receipt for 'com.apple.pkg.DeveloperToolsCLI' found at '/'.gyp: No Xcode or CLT version detected!gyp ERR! configure errorgyp ERR! stack Error: `gyp` failed with exit code: 1gyp ERR! stack at ChildProcess.onCpExit (/usr/local/lib/node_modules/npm/node_modules/node-gyp/lib/configure.js:351:16)gyp ERR! stack at ChildProcess.emit (events.js:193:13)gyp ERR! stack at Process.ChildProcess._handle.onexit (internal/child_process.js:255:12)gyp ERR! System Darwin 19.3.0gyp ERR! command "/usr/local/Cellar/node/11.14.0/bin/node" "/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js" "configure" "--fallback-to-build" "--module=/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/lib/binding/Release/node-v67-darwin-x64/fse.node" "--module_name=fse" "--module_path=/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/lib/binding/Release/node-v67-darwin-x64" "--napi_version=4" "--node_abi_napi=napi"gyp ERR! cwd /Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fseventsgyp ERR! node -v v11.14.0gyp ERR! node-gyp -v v5.0.7gyp ERR! not oknode-pre-gyp ERR! build errornode-pre-gyp ERR! stack Error: Failed to execute '/usr/local/Cellar/node/11.14.0/bin/node /usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js configure --fallback-to-build --module=/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/lib/binding/Release/node-v67-darwin-x64/fse.node --module_name=fse --module_path=/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/lib/binding/Release/node-v67-darwin-x64 --napi_version=4 --node_abi_napi=napi' (1)node-pre-gyp ERR! stack at ChildProcess.&lt;anonymous&gt; (/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/node_modules/node-pre-gyp/lib/util/compile.js:83:29)node-pre-gyp ERR! stack at ChildProcess.emit (events.js:193:13)node-pre-gyp ERR! stack at maybeClose (internal/child_process.js:999:16)node-pre-gyp ERR! stack at Process.ChildProcess._handle.onexit (internal/child_process.js:266:5)node-pre-gyp ERR! System Darwin 19.3.0node-pre-gyp ERR! command "/usr/local/Cellar/node/11.14.0/bin/node" "/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/node_modules/node-pre-gyp/bin/node-pre-gyp" "install" "--fallback-to-build"node-pre-gyp ERR! cwd /Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fseventsnode-pre-gyp ERR! node -v v11.14.0node-pre-gyp ERR! node-pre-gyp -v v0.10.0node-pre-gyp ERR! not okFailed to execute '/usr/local/Cellar/node/11.14.0/bin/node /usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js configure --fallback-to-build --module=/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/lib/binding/Release/node-v67-darwin-x64/fse.node --module_name=fse --module_path=/Users/louis/Documents/GitHub/jiangluyu.github.io/node_modules/fsevents/lib/binding/Release/node-v67-darwin-x64 --napi_version=4 --node_abi_napi=napi' (1)...以下省略 实际上，在尝试过使用如下命令 1xcode-select --install 进行修复时，并不成功。 解决方案如下： 12sudo rm -rf $(xcode-select -print-path)xcode-select --install Q2: hexo迁移去年在原先的笔记本上建立的项目，彼时对github了解甚少，没想过在不同电脑上更新的需求，甚至还因此断更了一年（笑），迁移步骤如下： ssh配置好后，克隆github上yourname.github.io项目到本地： 1git clone https://github.com/yourname/yourname.github.io.git 删除除了.git以外的所有文件； 将blog源文件中的所有文件复制到xxx.github.io的文件夹中，并将theme文件夹中各个主题中的.git文件夹删除； 创建hexo分支，并切换到hexo： 1git checkout -b hexo 将复制的文件提交到暂存区，并提交，推送至github： 123git add .git commit -m 'new branch source files'git push --set-upstream origin hexo 更新blog时，只需要照常即可： 12hexo cleanhexo d -g 切换至新电脑时，只需要执行如下命令： 1git clone -b hexo https://github.com/yourname/yourname.github.io 在ssh配置正确，npm安装依赖后，即可更新。 Q3: 无法备份/themes在删掉themes中的所有主题的.git之后，发现使用如下命令： 123git add .git comment -m 'write your comment here'git push 依然无法成功将自己修改过的主题提交到github上。 解决方案如下：在确保删除了各个主题的.git文件后，执行如下命令： 1234git rm --cached -r themesgit add themesgit commit -m 'write your comment here'git push]]></content>
      <categories>
        <category>bugfix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[E867-转置矩阵]]></title>
    <url>%2F2020%2F02%2F14%2FE867-%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[给定一个矩阵 A， 返回 A 的转置矩阵。 矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。 示例 1： 输入：[[1,2,3],[4,5,6],[7,8,9]]输出：[[1,4,7],[2,5,8],[3,6,9]]示例 2： 输入：[[1,2,3],[4,5,6]]输出：[[1,4],[2,5],[3,6]] 提示： 1 &lt;= A.length &lt;= 10001 &lt;= A[0].length &lt;= 1000 方法一：遍历复制重新创建一个vector，依照规律遍历并复制对应数字到所创建的vector中。 12345678910111213141516class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; transpose(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123; int col = A[0].size(); int row = A.size(); vector&lt;vector&lt;int&gt;&gt; res(col); for (int iRow = 0; iRow &lt; col; iRow++) &#123; for (int iCol = 0; iCol &lt; row; iCol++) &#123; res[iRow].push_back(A[iCol][iRow]); &#125; &#125; return res; &#125;&#125;; 复杂度分析 时间复杂度：O(M×N)，其中M与N分别为矩阵A的行数和列数。 空间复杂度：O(M×N)。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>matrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[E206-反转链表]]></title>
    <url>%2F2020%2F02%2F14%2FE206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 方法一：外部容器将链表转存至新的容器vector内，再利用vector本身的reverse_iterator进行反向遍历，将内容一一对应存入链表节点内。 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (head == NULL) &#123; return head; &#125; vector&lt;int&gt; store; while (head != NULL) &#123; store.push_back(head-&gt;val); head = head-&gt;next; &#125; ListNode* resHead = new ListNode(0); ListNode* p = resHead; ListNode* q = nullptr; p-&gt;val = *(store.rbegin()); for (vector&lt;int&gt;::reverse_iterator riter = store.rbegin() + 1; riter != store.rend(); riter++) &#123; q = new ListNode(0); q-&gt;val = *riter; p-&gt;next = q; p = q; &#125; p-&gt;next = NULL; return resHead; &#125;&#125;; 复杂度分析 时间复杂度：O(n)，其中n为链表长度。 空间复杂度：O(n)。 方法二：迭代在遍历列表时，将当前节点的 next 指针改为指向它的前一个节点。分别需要一个指针用来记录上一个节点（previous），当前节点（current）以及下一个节点（next）。 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (head == NULL) &#123; return head; &#125; ListNode* prev = nullptr; ListNode* curr = head; while (curr != NULL) &#123; ListNode* nextTemp = nullptr; nextTemp = curr-&gt;next; curr-&gt;next = prev; prev = curr; curr = nextTemp; &#125; return prev; &#125;&#125;; 复杂度分析 时间复杂度：O(n)，其中n为链表长度。 空间复杂度：O(1)。 方法三：递归递归方法比较难理解，假设我们传入的链表为1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL，那么传入的head即节点1，递归令节点curr等于reverseList(head-&gt;next)，终止条件为head或head-&gt;next为空，并返回head。 在这个例子中，最后一层返回的即节点5，此时head指向节点4，我们令head-&gt;next-&gt;next = head，即1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;4： 接着，令head-&gt;next = null，即1-&gt;2-&gt;3-&gt;4-&gt;null且5-&gt;4： 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return head; &#125; ListNode* curr = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return curr; &#125;&#125;; 复杂度分析 时间复杂度：O(n)，其中n为链表长度。 空间复杂度：O(n)，递归至n层。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[少少]]></title>
    <url>%2F2019%2F01%2F04%2F%E5%B0%91%E5%B0%91%2F</url>
    <content type="text"><![CDATA[“如果提前了解了你们的人生，不知你们是否还会有勇气前来？” 再想起这句台词，电影都不知是何日看的了，挺早的。 我想说，有啊，就是少点。 2018-2019的交界时，立了好多flag，还试着跟一波朋友圈网易云音乐flag的热潮，无奈轰趴的那个夜晚，明明显示着长按保存，我却怎么样都唤不出菜单。怎么回事？谁知道呢。我只知道，最后我放弃了，只在总结里添了一行信号微弱的粗浅论调。熬夜的后遗症还在，大致就是睡不醒醒就睡，萎靡着，空洞着，压缩着吃饭、喝水等等一切行动的欲望来恢复精力。 打卡到最后几个眼神都是迷离的，隐隐听着音响里的歌，再也不循环那个熟悉的、混杂的歌单了，随便什么，有声音就好，不是神曲就好，一个人的世界里，它们都有自己的声音。 喜欢美短，想取个名字叫辛巴(Simba)，而所有的不喜欢和不知道，是还没准备好。 出门就是一场义无反顾的冒险，不消多远，上厕所都赶时间，怕残羹被收走。相信世间温暖，禁不住旁人冷漠，观察得更多，想得更多，连绝对不常用的“plover”都变得难以忘记，才发现所谓的幸运四叶草，也只不过是“four-leaf clover”（四叶的三叶草）而已。 幸好，镜头下死水微澜，是小野鸭在凫水。 不要等风来，跑起来，它就奔向了你。]]></content>
      <categories>
        <category>随便写写</category>
      </categories>
      <tags>
        <tag>随想</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不问归期来路]]></title>
    <url>%2F2019%2F01%2F01%2F%E4%B8%8D%E9%97%AE%E5%BD%92%E6%9C%9F%E6%9D%A5%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[这条路上的人有很多，在2018这段收费公路上，说真的，还挺挤的（笑）。 我想了好久，这一路我怎么过来的，遇到了哪些人，经历了哪些事。 全部写下来吧。 2017.12.31已经忘了写了什么又删了什么。 2018.01.01 去年的年终总结嗷。 我的2017，疯狂而又迷人。疯狂而安静的高考倒计时，逃晚自习躺操场上看星星，也只有那会儿做得出。“幽暗的萤绿色灯光下，每个人的背影都漾在周边的空气里，或散步，或疾走，或嬉戏，或追闹，放在这片草坪上，零落得像幅静止的画。”这是我的草坪，它留在那儿了。“我有故事，你有酒吗?”“抱歉，我的故事那么无聊，没劲。”高考，以前很看重，可能以后也很看重，至少现在我觉得没那么重要了。它只会决定你的下一步往哪儿走，可是无论你往哪儿走，都会认识一堆槽点满满却又可爱至极的人。俗点，跟史主任说得一样，“只是决定你以后在哪个城市打英雄联盟”，过了那么久，只是英雄联盟变成了吃鸡王者了吧。想得最多的，还怕是那个高考前阵的夜话闲聊和传奇的宜兴爱情故事。六月，考场上潇洒走一回，和想的一样，真的“洒”了一点点，但其实，就像用杯子运水，除非下雨天，否则即使手再稳，也会失去些，蒸发什么的，总是存在的。何况我手也没那么稳。第一首想唱的歌，&lt;成都&gt;，没成想真的来了成都，火锅冒菜串串川菜的天堂，可惜傻鸡没来@驴蛋蛋。一水儿的来四川的兄弟，只剩下一个@连长。诶，啥时候寄点特产来不？@驴蛋蛋想你早日脱单，在线等，挺急的。@许致远 我可能欠自己一份真正的疯狂，至少我现在不后悔。祝你安好，早日脱单。这里得留给帅杨 @骚羊…… 的未成行的和桥烧烤和带劲的重庆小面。@周成瑜 阿华还在田里努力耕作。@徐雨涵 山上新鲜采摘的熊猫。@冯羽韬 骚还是你骚。@朱刚宪 47474747!北边的，南边的，我终将从你们的轨迹中渐渐淡去。我希望那一刻哪怕我糊涂了，我们之间也比陌生人多一层回忆的纸。鸟蒋，蒋汤姆，大炮，懒&lt;菜?傻?-.-&gt;猫，蒋医师，他们都在原地，不会动了，但我会一直带着他们走，直到我走不动了为止。七月上午学车，下午学吉他，最长最浪的暑假没浪起来，单纯充实。吃了贼多各种酒店的谢师宴，感觉神奇，好吧多到不想吃了。@吴好猛哦 八月初疯狂的两人第一次出国自由行，语言不通，眼里全是天书，却那么有趣。因为交通问题去到岚山没坐小火车也没有漂流;在奈良喂鹿，衣服裤子被鹿咬得湿湿的;心斋桥为了买东西，暴走近四万步，穿梭人流，崩溃得不行;又累又饿的朝日生啤+大阪烧，爽;环球影城奇幻的项目和瓢泼的大雨毫不冲突;因为行李受限而穿了n件衣服n条裤子上飞机……遇见了有趣的人有趣的事，还是很好玩呀(｡ì_í｡)田子坊，南京路，科技馆，迪士尼，还记得小时候呆的魔都，没怎么变，迪士尼的人数是真的骚了呀……佛系，佛系。凌晨出发来成都，和爸妈在附近吃了第一顿火锅，那滋味已经忘了，可能比现在的，要美一些。哦对，尼玛全聚德呢？@驴蛋蛋最后又回来了啊:报道，入学，相识，面试，学习……期末。你好，我的2018。 2018.02放假回家三件事 两件事：学Java、TOEFL、宣传部作业（海报和手绘视频~） 视频：https://www.bilibili.com/video/av20413559 2018.03.01做了一个奇怪的梦。 2018.03为了看牙，来来回回上海-成都飞了两三次。 2018.03这学期周三半学期满课来着… 2018.04.15立了一个flag，好的，倒了，今年会加油的哈哈哈哈哈。 有时候直接发公众号了来着。 链接：https://www.jiangluyu.com 2018.05.12复联上映，过了几天去看了，死了很多人。 2018.05.17昨天夜里江安雷暴，窗边的我并没有醒。 2018.05.24这事我要记住的hhh 2018.05.28不知道@连长你记住没有，我帮你回忆回忆hhh 2018.06不管是上课还是考试月今年都有看世界杯嗷。 2018.06.28水漫三八广场 2018.07没想到军训当了标兵。 阿飞走的时候说：“走起，川大的兄弟，未来的精英们，好好学习，相逢就是缘分。” 2018.08.22六级没到600（591），90免修失败 2018.09.14学生会宣讲效果正式破产 2018.10.04第一次参加游戏线下活动 2018.11.25正式加入飞扬（拜师了） 2018.11.30？ 2018.12.09迎新晚会结束了（老父亲般欣慰） 还有很多很多啊，上面的只是空间整理的。 比如换掉了用了一年半一直很喜欢的签名：一棵草，也会为了春天不遗余力。 可能比起上一段路，这一段没有那么冒险刺激，没有那么诗情画意，更多的是躲在幽暗中努力，和朋友们一起患难。这一年睡得不多，无论是从寒假回家开始，还是在学校肝视频，肝项目，肝活动，再加上一些习惯性晚睡，有时候丧，有时候暖。现在想想度过漫漫长夜一定不容易吧，睡觉一定是最好的对策。 生活不易，念且维坚。很感谢你们，这一段路收到了很多惊喜和温暖，还有时不时的交流与吐槽，这一路给了我很重要的力量，黄金日子里，愿友谊常在。路是自己选的，很早的时候就选了，很幸运能够遇到你们，都是可以独舞的灵魂。 今年刷了很多电影，顺便整理了一下，做个参考和留念。【附在后面】 眼看到了2019年了，希望今年拿下期末，拿下TOEFL，KO项目，KO论文，头发变多，继续单身，找到更多的动力，认识更多有趣的灵魂。嗯，剩下的我还没想好。2019应该有2019自己的喜悦与悲伤留给我吧，挺期待的。（flag可别倒啊！） 今年跨年和家乡来的小伙伴们过了，很冷很难忘，真的在成都的街头走一走，还走了一年（笑）。 说来今年成都下雪了，但是江安很小很短，没有积过雪。 窗外无雪，却念雪上人。 附： 弱点 ※※※※※※ 美好的意外 ※ 火锅英雄 ※ 全民情敌 ※※※ 飞行家 ※※※※ 127小时 ※※※ 白日梦想家 ※※※※※※ 真爱至上 ※※※※※※ 彗星来的那一夜 ※※※※ 大空头 ※※※※ 我是谁：没有绝对安全的系统 ※※※ 轻松自由 ※※※※※※ 孤儿怨 / 放牛班的春天 ※※※※※※ 监守自盗 ※※ 返老还童 ※※※※※※ 点球成金 ※※※※※※ 死亡医生 ※※※※ 大而不倒 ※※※※※※ 社交网络 ※※※※※ 成事在人 ※※※※ 无双 ※※※ 传奇的诞生 ※※※※ 你好，之华 ※※※※ 胖子行动队 ※※ 月球 ※※※※ 禁闭岛 ※※※※※※ 私人订制 ※※※ 甲方乙方 ※※※ 让子弹飞 ※※※※※ 一步之遥 ? 邪不压正 ※※※※ 看不见的客人 ※※※※※※ 三块广告牌 ※※※※※※ 玉子爱情故事 ※※※ 达拉斯买家俱乐部 ※※※※※※ 最佳出价 ※※※※ 再次出发 ※※※※※※ 惊天魔盗团2 ※※ 惊天魔盗团 ※※※※ 的士速递 ※※※※ 爱情公寓 ? 超体 ※※※※ 闻香识女人 ※※※※※※ 神奇动物在哪里 ※※※※ 奇异博士 ※※※※ 美丽心灵 ※※※※※※ 心花路放 ※※ 幸福终点站 / 星运里的错 ※※※※※ 头号玩家 ※※※※※※ 闪灵 ※※※※ 泰迪熊2 ※※※ 姚明年 ※※※ 钢琴家 ※※※※※ 火星救援 ※※※※※※ 解救吾先生 ※※※※ 昨日青空 ※※※ 星际穿越 ※※※※※※ 至暗时刻 ※※※※※※]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
</search>
